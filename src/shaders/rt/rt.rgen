
#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_ARB_shader_clock : enable

#include "rtcommon.glsl"

// ray info
layout(location = 0) rayPayloadEXT hitPayload payload;

// IO
layout(binding = 0) uniform UniformBufferObject {
    mat4 V, P, iV, iP;
} cam;

layout(binding = 6) uniform accelerationStructureEXT TLAS;
layout(binding = 7, rgba32f) uniform image2D image;

vec3 directLight(vec3 o, vec3 d) {
	
    uint flags = gl_RayFlagsOpaqueEXT;

	hitPayload old_payload = payload;
	
	payload.is_direct = true;
    traceRayEXT(TLAS,  		 // acceleration structure
                flags,       // rayFlags
                0xFF,        // cullMask
                0,           // sbtRecordOffset
                0,           // sbtRecordStride
                0,           // missIndex
                o,           // ray origin
                EPS,         // ray min range
                d,           // ray direction
                LARGE_DIST,  // ray max range
                0            // payload (location = 1)
    );

	vec3 hit_emis = payload.emissive;
	payload = old_payload;
	return hit_emis;
}

void main() {

    payload.seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, consts.frame * int(clockARB()));
    vec3 o = (cam.iV * vec4(0, 0, 0, 1)).xyz;
    vec3 acc = vec3(0);

    for(int s = 0; s < consts.samples; s++) {
        
        const vec2 jitter = consts.frame == 0 ? vec2(0.5) : vec2(randf(payload.seed), randf(payload.seed));
        const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + jitter;
        const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
        vec4 target = cam.iP * vec4(inUV * 2.0 - 1.0, 0, 1);
        vec4 direction = cam.iV * vec4(target.xyz, 0);

        vec3 throughput = vec3(1);
        payload.nextWeight = vec3(0);
        payload.nextO = o;
        payload.nextD = normalize(direction.xyz);
        payload.depth = 0;
        payload.misWeight = 1;

        for(; payload.depth < consts.max_depth; payload.depth++) {
            payload.is_direct = false;
            payload.shadowWeight = vec3(0);
            traceRayEXT(TLAS,           // acceleration structure
                gl_RayFlagsOpaqueEXT,   // rayFlags
                0xFF,                   // cullMask
                0,                      // sbtRecordOffset
                0,                      // sbtRecordStride
                0,                      // missIndex
                payload.nextO,          // ray origin
                EPS,                    // ray min range
                payload.nextD,          // ray direction
                LARGE_DIST,             // ray max range
                0                       // payload (location = 0)
            );

            if(consts.use_nee == 1 && any(greaterThan(payload.shadowWeight, vec3(0))))
                acc += directLight(payload.nextO, payload.shadowD) * payload.shadowWeight * throughput;

            acc += payload.emissive * throughput;
            throughput *= payload.nextWeight;

            if(consts.use_rr == 1) {
                float pcont = min(max(throughput.x, max(throughput.y, throughput.z)) + 0.001, 0.95);
                if(randf(payload.seed) >= pcont)
                    break;
                throughput /= pcont;
            }
        }
    }

    vec3 avg = acc / consts.samples;
    if(consts.frame > 0) {
        float a         = 1.0f / float(consts.frame + 1);
        vec3  old_color = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(old_color, avg, a), 1.f));
    } else {
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(avg, 1.f));
    }
}
