
#version 450

#extension GL_ARB_separate_shader_objects : enable

layout (local_size_x = 32) in;

layout (binding = 0, std140) readonly buffer Queries
{
	vec4 queries[];
};

layout (binding = 1, std140) writeonly buffer Output
{
	vec4 closest_points[];
};

layout (binding = 2, std140) readonly buffer Vertices
{
	vec4 vertices[];
};

layout (binding = 3, std140) readonly buffer Indices
{
	uvec4 indices[];
};

layout (push_constant) uniform constants
{
	uint n_triangles;
};

struct Triangle {
    vec3 v0;
    vec3 v1;
    vec3 v2;
};

Triangle load_triangle(uint i) {
    Triangle t;
	uvec4 v = indices[i];
    t.v0 = vertices[v.x].xyz;
    t.v1 = vertices[v.y].xyz;
    t.v2 = vertices[v.z].xyz;
    return t;
}

vec3 cp_triangle(vec3 q, Triangle t) {

	vec3 ab = t.v1 - t.v0;
	vec3 ac = t.v2 - t.v0;
	vec3 ax = q - t.v0;

	float d1 = dot(ab, ax);
	float d2 = dot(ac, ax);
	if (d1 <= 0.0f && d2 <= 0.0f) {
        return t.v0;
	}

	vec3 bx = q - t.v1;
	float d3 = dot(ab, bx);
	float d4 = dot(ac, bx);
	if (d3 >= 0.0f && d4 <= d3) {
        return t.v1;
	}

	vec3 cx = q - t.v2;
	float d5 = dot(ab, cx);
	float d6 = dot(ac, cx);
	if (d6 >= 0.0f && d5 <= d6) {
        return t.v2;
	}

	float vc = d1*d4 - d3*d2;
	if (vc <= 0.0f && d1 >= 0.0f && d3 <= 0.0f) {
		float v = d1/(d1 - d3);
		return t.v0 + ab*v;
	}

	float vb = d5*d2 - d1*d6;
	if (vb <= 0.0f && d2 >= 0.0f && d6 <= 0.0f) {
		float w = d2/(d2 - d6);
		return t.v0 + ac*w;
	}

	float va = d3*d6 - d5*d4;
	if (va <= 0.0f && (d4 - d3) >= 0.0f && (d5 - d6) >= 0.0f) {
		float w = (d4 - d3)/((d4 - d3) + (d5 - d6));
		return t.v1 + (t.v2 - t.v1)*w;
	}

	float denom = 1.0f/(va + vb + vc);
	float v = vb*denom;
	float w = vc*denom;
	return t.v0 + ab*v + ac*w;
}

void main()
{
	uint q_idx = gl_GlobalInvocationID.x;
    vec3 query = queries[q_idx].xyz;

    float best_dist = 1000000000;
    vec3 best_point;

    for(uint i = 0; i < n_triangles; i++) {
        vec3 p = cp_triangle(query, load_triangle(i));
        float d = length(p - query);
        if(d < best_dist) {
            best_dist = d;
            best_point = p;
        }
    }

    closest_points[q_idx] = vec4(best_point, 0.0f);
}
