
#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "bvhcommon.glsl"

struct Node {
	vec4 bmin, bmax;
	int l, r, start, size;
};

layout (binding = 3, std140) readonly buffer Nodes
{
	Node nodes[];
};

#define MAX_DEPTH 64
#define PARENT 0
#define SIBLING 1
#define CHILD 2

// Interior node: n.start = parent
// Leaf node: n.l = n.r and n.l = parent

void ray_primitives(vec3 o, vec3 d, Node node, inout vec3 first_hit, inout float best_dist) {
	int s = node.start;
	int e = s + node.size;
	for (int t = s; t < e; t++) {
		vec3 hitp;
		float hitd;
		bool h = hit_triangle(o, d, hitp, hitd, triangles[t]);
		if(h && hitd < best_dist) {
			best_dist = hitd;
			first_hit = hitp;
		}
	}
}

void cpq_primitives(vec3 q, Node node, inout vec3 best_point, inout float best_dist) {
	int s = node.start;
	int e = s + node.size;
	for (int t = s; t < e; t++) {
		vec3 p = cp_triangle(q, triangles[t]);
		float dt = length(p-q);
		if(dt < best_dist) {
			best_dist = dt;
			best_point = p;
		}
	}
}

void traverse_ray_stackless(vec3 o, vec3 d, inout vec3 first_hit, inout float best_dist) {

	int n = nodes[0].l;
	int state = PARENT;

	while(true) {

		Node node = nodes[n];
		if(state == PARENT) {
			
			float box_dist;
			if(hit_bbox(o, d, node.bmin.xyz, node.bmax.xyz, best_dist, box_dist)) {
				if(node.l == node.r) {
					
					ray_primitives(o, d, node, first_hit, best_dist);
					// Finished, traverse right subtree
					n = nodes[node.l].r;
					state = SIBLING;

				} else {
					// Traverse left subtree
					n = node.l;
					state = PARENT;
				}
			} else {
				// Finished, traverse right subtree
				if(node.l == node.r) {
					n = nodes[node.l].r;
				} else {
					n = nodes[node.start].r;
				}
				state = SIBLING;
			}

		} else if(state == SIBLING) {

			float box_dist;
			if(hit_bbox(o, d, node.bmin.xyz, node.bmax.xyz, best_dist, box_dist)) {
				if(node.l == node.r) {

					ray_primitives(o, d, node, first_hit, best_dist);

					// Finished, go up
					n = node.l;
					state = CHILD;

				} else {

					// Traverse left subtree
					n = node.l;
					state = PARENT;
				}
			} else {
				if(node.l == node.r) {
					n = node.l;
				} else {
					n = node.start;
				}
				state = CHILD;
			}
		} else /* state == CHILD */ {
			
			// Traversal complete
			if(n == 0) return;
			
			int p_n;
			if(node.l == node.r) {
				p_n = node.l;
			} else {
				p_n = node.start;
			}

			Node parent = nodes[p_n];
			// Traverse right subtree
			if(n == parent.l) {

				n = parent.r;
				state = SIBLING;

			// Finished, go up
			} else {

				n = p_n;
				state = CHILD;
			}
		}
	}
}

void traverse_ray_stack(vec3 o, vec3 d, inout vec3 first_hit, inout float best_dist) {

	uint stack[MAX_DEPTH];
	uint stack_n = 1;
	stack[0] = 0;

	while(stack_n > 0) {
		uint n = stack[--stack_n];
		Node node = nodes[n];

		if(node.l == node.r) {
			ray_primitives(o, d, node, first_hit, best_dist);
			continue;
		}

		float l_boxd, r_boxd;
		bool l_hit = hit_bbox(o, d, nodes[node.l].bmin.xyz, nodes[node.l].bmax.xyz, best_dist, l_boxd);
		bool r_hit = hit_bbox(o, d, nodes[node.r].bmin.xyz, nodes[node.r].bmax.xyz, best_dist, r_boxd);
		if(l_hit && r_hit) {
			stack[stack_n++] = l_boxd < r_boxd ? node.l : node.r;
			stack[stack_n++] = l_boxd < r_boxd ? node.r : node.l;
		} else if(l_hit) {
			stack[stack_n++] = node.l;
		} else if(r_hit) {
			stack[stack_n++] = node.r;
		}
	}
}

void traverse_cpq_stackless(vec3 q, inout vec3 best_point, inout float best_dist) {

	int n = nodes[0].l;
	int state = PARENT;

	while(true) {

		Node node = nodes[n];
		if(state == PARENT) {
			
			float bclose, bfar;
			box_dist(q, node.bmin.xyz, node.bmax.xyz, bclose, bfar);
			if(bclose < best_dist) {
				best_dist = min(best_dist, bfar);

				if(node.l == node.r) {
					
					cpq_primitives(q, node, best_point, best_dist);
					// Finished, traverse right subtree
					n = nodes[node.l].r;
					state = SIBLING;

				} else {
					// Traverse left subtree
					n = node.l;
					state = PARENT;
				}
			} else {
				// Finished, traverse right subtree
				if(node.l == node.r) {
					n = nodes[node.l].r;
				} else {
					n = nodes[node.start].r;
				}
				state = SIBLING;
			}

		} else if(state == SIBLING) {

			float bclose, bfar;
			box_dist(q, node.bmin.xyz, node.bmax.xyz, bclose, bfar);
			if(bclose < best_dist) {
				best_dist = min(best_dist, bfar);
				if(node.l == node.r) {

					cpq_primitives(q, node, best_point, best_dist);

					// Finished, go up
					n = node.l;
					state = CHILD;

				} else {

					// Traverse left subtree
					n = node.l;
					state = PARENT;
				}
			} else {
				if(node.l == node.r) {
					n = node.l;
				} else {
					n = node.start;
				}
				state = CHILD;
			}
		} else /* state == CHILD */ {
			
			// Traversal complete
			if(n == 0) return;
			
			int p_n;
			if(node.l == node.r) {
				p_n = node.l;
			} else {
				p_n = node.start;
			}

			Node parent = nodes[p_n];
			// Traverse right subtree
			if(n == parent.l) {

				n = parent.r;
				state = SIBLING;

			// Finished, go up
			} else {

				n = p_n;
				state = CHILD;
			}
		}
	}
}

void traverse_cpq_stack(vec3 q, inout vec3 best_point, inout float best_dist) {

	uint stack[MAX_DEPTH];
	uint stack_n = 1;
	stack[0] = 0;

	while(stack_n > 0) {
		uint n = stack[--stack_n];
		Node node = nodes[n];

		if(node.l == node.r) {
			cpq_primitives(q, node, best_point, best_dist);
			continue;
		}

		float l_close, l_far;
		float r_close, r_far;
		box_dist(q, nodes[node.l].bmin.xyz, nodes[node.l].bmax.xyz, l_close, l_far);
		box_dist(q, nodes[node.r].bmin.xyz, nodes[node.r].bmax.xyz, r_close, r_far);
		bool l_hit = l_close < best_dist;
		bool r_hit = r_close < best_dist;

		if(l_hit && r_hit) {
			best_dist = min(best_dist, min(l_far, r_far));
			stack[stack_n++] = l_close < r_close ? node.l : node.r;
			stack[stack_n++] = l_close < r_close ? node.r : node.l;
		} else if(l_hit) {
			best_dist = min(best_dist, l_far);
			stack[stack_n++] = node.l;
		} else if(r_hit) {
			best_dist = min(best_dist, r_far);
			stack[stack_n++] = node.r;
		}
	}
}

void traverse_ray(vec3 o, vec3 d, inout vec3 first_hit, inout float best_dist) {
	if(stackless == 1) traverse_ray_stackless(o,d,first_hit,best_dist);
	else traverse_ray_stack(o,d,first_hit,best_dist);
}

void traverse_cpq(vec3 q, inout vec3 best_point, inout float best_dist) {
	if(stackless == 1) traverse_cpq_stackless(q, best_point, best_dist);
	else traverse_cpq_stack(q, best_point, best_dist);
}

