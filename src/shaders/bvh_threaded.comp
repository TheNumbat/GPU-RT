
#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "bvhcommon.glsl"

layout (local_size_x = 32) in;

struct Node {
	vec4 bmin, bmax;
	int start, size, hit, miss;
};

layout (binding = 0, std140) readonly buffer Queries
{
	vec4 queries[];
};

layout (binding = 1, std140) writeonly buffer Output
{
	vec4 results[];
};

layout (binding = 2, std140) readonly buffer Primitives
{
	Triangle triangles[];
};

layout (binding = 3, std140) readonly buffer Nodes
{
	Node nodes[];
};

layout (push_constant) uniform Constants
{
	int n_nodes;
	int n_tris;
	int trace_rays;
};

void traverse_ray(vec3 o, vec3 d, inout vec3 first_hit, inout float best_dist) {

	int next_node = 0;
	for (int n = 0; n < n_nodes; n++) {
		if (n != next_node) {
			continue;
		}

		float box_d;
		bool hit = hit_bbox(o, d, nodes[n].bmin.xyz, nodes[n].bmax.xyz, box_d, best_dist);
		
		bool leaf = nodes[n].size > 0;
		if (hit) {
			best_dist = min(best_dist, box_d);
			next_node = nodes[n].hit;
		} else {
			next_node = nodes[n].miss;
		}

		if (hit && leaf) {
			int s = nodes[n].start;
			int e = s + nodes[n].size;
			for (int t = s; t < e; t++) {
				vec3 hitp;
				float hitd;
				bool h = hit_triangle(o, d, hitp, hitd, triangles[t]);
				if(h && hitd < best_dist) {
					best_dist = hitd;
					first_hit = hitp;
				}
			}
		}
	}
}

void traverse_cpq(vec3 q, out vec3 best_point, inout float best_dist) {

	int next_node = 0;
	for (int n = 0; n < n_nodes; n++) {
		if (n != next_node) {
			continue;
		}

		float bclose, bfar;
		box_dist(q, nodes[n].bmin.xyz, nodes[n].bmax.xyz, bclose, bfar);
		
		bool hit = bclose < best_dist;
		bool leaf = nodes[n].size > 0;

		if (hit) {
			best_dist = min(best_dist, bfar);
			next_node = nodes[n].hit;
		} else {
			next_node = nodes[n].miss;
		}

		if (hit && leaf) {
			int s = nodes[n].start;
			int e = s + nodes[n].size;
			for (int t = s; t < e; t++) {
				vec3 p = cp_triangle(q, triangles[t]);
				float dt = length(p-q);
				if(dt < best_dist) {
					best_dist = dt;
					best_point = p;
				}
			}
		}
	}
}

void main()
{
    if(trace_rays == 1) {
        
        uint q_idx = 2 * gl_GlobalInvocationID.x;
        vec3 o = queries[q_idx].xyz;
        vec3 d = queries[q_idx+1].xyz;

        float hit_dist = LARGE_DIST;
        vec3 hit_point = vec3(INF);
        traverse_ray(o, d, hit_point, hit_dist);
        results[q_idx / 2] = vec4(hit_point, 0.0f);

    } else {

        uint q_idx = gl_GlobalInvocationID.x;
        vec3 query = queries[q_idx].xyz;

        float best_dist = LARGE_DIST;
        vec3 best_point = vec3(INF);
        traverse_cpq(query, best_point, best_dist);
        results[q_idx] = vec4(best_point, 0.0f);
    }
}
