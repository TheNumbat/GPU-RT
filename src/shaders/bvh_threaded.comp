
#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "bvhcommon.glsl"

struct Node {
	vec4 bmin, bmax;
	int start, size, hit, miss;
};

layout (binding = 3, std140) readonly buffer Nodes
{
	Node nodes[];
};

void traverse_ray(vec3 o, vec3 d, inout vec3 first_hit, inout float best_dist) {

	int next_node = 0;
	for (int n = 0; n < n_nodes; n++) {
		if (n != next_node) {
			continue;
		}

		float min_d;
		bool hit = hit_bbox(o, d, nodes[n].bmin.xyz, nodes[n].bmax.xyz, best_dist, min_d);
		bool leaf = nodes[n].size > 0;
		if (hit) {
			next_node = nodes[n].hit;
		} else {
			next_node = nodes[n].miss;
		}

		if (hit && leaf) {
			int s = nodes[n].start;
			int e = s + nodes[n].size;
			for (int t = s; t < e; t++) {
				vec3 hitp;
				float hitd;
				bool h = hit_triangle(o, d, hitp, hitd, triangles[t]);
				if(h && hitd < best_dist) {
					best_dist = hitd;
					first_hit = hitp;
				}
			}
		}
	}
}

void traverse_cpq(vec3 q, inout vec3 best_point, inout float best_dist) {

	int next_node = 0;
	for (int n = 0; n < n_nodes; n++) {
		if (n != next_node) {
			continue;
		}

		float bclose, bfar;
		box_dist(q, nodes[n].bmin.xyz, nodes[n].bmax.xyz, bclose, bfar);
		
		bool hit = bclose < best_dist;
		bool leaf = nodes[n].size > 0;

		if (hit) {
			best_dist = min(best_dist, bfar);
			next_node = nodes[n].hit;
		} else {
			next_node = nodes[n].miss;
		}

		if (hit && leaf) {
			int s = nodes[n].start;
			int e = s + nodes[n].size;
			for (int t = s; t < e; t++) {
				vec3 p = cp_triangle(q, triangles[t]);
				float dt = length(p-q);
				if(dt < best_dist) {
					best_dist = dt;
					best_point = p;
				}
			}
		}
	}
}
