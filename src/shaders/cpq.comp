
#version 450

#extension GL_ARB_separate_shader_objects : enable

layout (local_size_x = 32) in;

struct Triangle {
    vec4 v0, v1, v2;
};

struct Node {
	vec4 bmin, bmax;
	int start, size, hit, miss;
};

layout (binding = 0, std140) readonly buffer Queries
{
	vec4 queries[];
};

layout (binding = 1, std140) writeonly buffer Output
{
	vec4 closest_points[];
};

layout (binding = 2, std140) readonly buffer Primitives
{
	Triangle triangles[];
};

layout (binding = 3, std140) readonly buffer Nodes
{
	Node nodes[];
};

layout (push_constant) uniform Constants
{
	int n_nodes;
	int n_tris;
};

vec3 cp_triangle(vec3 q, int idx) {

	vec3 v0 = triangles[idx].v0.xyz;
	vec3 v1 = triangles[idx].v1.xyz;
	vec3 v2 = triangles[idx].v2.xyz;

	vec3 ab = v1 - v0;
	vec3 ac = v2 - v0;
	vec3 ax = q - v0;

	float d1 = dot(ab, ax);
	float d2 = dot(ac, ax);
	if (d1 <= 0.0f && d2 <= 0.0f) {
        return v0;
	}

	vec3 bx = q - v1;
	float d3 = dot(ab, bx);
	float d4 = dot(ac, bx);
	if (d3 >= 0.0f && d4 <= d3) {
        return v1;
	}

	vec3 cx = q - v2;
	float d5 = dot(ab, cx);
	float d6 = dot(ac, cx);
	if (d6 >= 0.0f && d5 <= d6) {
        return v2;
	}

	float vc = d1*d4 - d3*d2;
	if (vc <= 0.0f && d1 >= 0.0f && d3 <= 0.0f) {
		float v = d1/(d1 - d3);
		return v0 + ab*v;
	}

	float vb = d5*d2 - d1*d6;
	if (vb <= 0.0f && d2 >= 0.0f && d6 <= 0.0f) {
		float w = d2/(d2 - d6);
		return v0 + ac*w;
	}

	float va = d3*d6 - d5*d4;
	if (va <= 0.0f && (d4 - d3) >= 0.0f && (d5 - d6) >= 0.0f) {
		float w = (d4 - d3)/((d4 - d3) + (d5 - d6));
		return v1 + (v2 - v1)*w;
	}

	float denom = 1.0f/(va + vb + vc);
	float v = vb*denom;
	float w = vc*denom;
	return v0 + ab*v + ac*w;
}

float box_dist(vec3 q, vec3 bmin, vec3 bmax) {
	vec3 u = bmin - q;
	vec3 v = q - bmax;
	vec3 c = max(max(u,v),0);
	return length(c);
}

// adapted from https://stackoverflow.com/questions/55479683/traversal-of-bounding-volume-hierachy-in-shaders
void traverse(vec3 q, out vec3 best_point, inout float best_dist) {

	int next_node = 0;
	for (int n = 0; n < n_nodes; n++) {
		if (n != next_node) {
			continue;
		}

		float d = box_dist(q, nodes[n].bmin.xyz, nodes[n].bmax.xyz);
		bool hit = d < best_dist;
		bool leaf = nodes[n].size > 0;

		if (hit) {
			next_node = nodes[n].hit;
		} else {
			next_node = nodes[n].miss;
		}

		if (hit && leaf) {
			int s = nodes[n].start;
			int e = s + nodes[n].size;
			for (int t = s; t < e; t++) {
				vec3 p = cp_triangle(q, t);
				float dt = length(p-q);
				if(dt < best_dist) {
					best_dist = dt;
					best_point = p;
				}
			}
		}
	}
}

void main()
{
	uint q_idx = gl_GlobalInvocationID.x;
    vec3 query = queries[q_idx].xyz;

    float best_dist = 10000000.0;
    vec3 best_point;

	traverse(query, best_point, best_dist);

    closest_points[q_idx] = vec4(best_point, 0.0f);
}
