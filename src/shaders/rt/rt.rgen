
#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_ARB_shader_clock : enable

#include "rtcommon.glsl"

// ray info
layout(location = 0) rayPayloadEXT hitPayload payload;

// IO
layout(binding = 0) uniform UniformBufferObject {
    mat4 V, P, iV, iP;
} cam;

layout(binding = 5) uniform accelerationStructureEXT topLevelAS;
layout(binding = 6, rgba32f) uniform image2D image;

void main() {

    payload.seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, consts.frame * int(clockARB()));
    vec3 o = (cam.iV * vec4(0, 0, 0, 1)).xyz;
    vec3 acc = vec3(0);

    for(int s = 0; s < consts.samples; s++) {
        
        const vec2 jitter = consts.frame == 0 ? vec2(0.5) : vec2(randf(payload.seed), randf(payload.seed));
        const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + jitter;
        const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
        vec4 target = cam.iP * vec4(inUV * 2.0 - 1.0, 0, 1);
        vec4 direction = cam.iV * vec4(target.xyz, 0);

        vec3 throughput = vec3(1);
        payload.nextWeight = vec3(0);
        payload.nextO = o;
        payload.nextD = normalize(direction.xyz);
        payload.depth = 0;

        for(; payload.depth < consts.max_depth; payload.depth++) {
            traceRayEXT(topLevelAS,     // acceleration structure
                gl_RayFlagsOpaqueEXT,   // rayFlags
                0xFF,                   // cullMask
                0,                      // sbtRecordOffset
                0,                      // sbtRecordStride
                0,                      // missIndex
                payload.nextO,          // ray origin
                0.001,                  // ray min range
                payload.nextD,          // ray direction
                LARGE_DIST,             // ray max range
                0                       // payload (location = 0)
            );
            acc += payload.emissive * throughput;
            throughput *= payload.nextWeight;
        }
    }

    vec3 avg = acc / consts.samples;
    if(consts.frame > 0) {
        float a         = 1.0f / float(consts.frame + 1);
        vec3  old_color = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(old_color, avg, a), 1.f));
    } else {
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(avg, 1.f));
    }
}
