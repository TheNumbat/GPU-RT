
#version 460
#extension GL_GOOGLE_include_directive : enable

#include "rtcommon.glsl"

// ray info
layout(location = 0) rayPayloadEXT vec3 payload;

// IO
layout(binding = 0) uniform UniformBufferObject {
    mat4 V, P, iV, iP;
} cam;

layout(binding = 5) uniform accelerationStructureEXT topLevelAS;
layout(binding = 6, rgba32f) uniform image2D image;

void main() {

    uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, consts.frame);
    vec3 o = (cam.iV * vec4(0, 0, 0, 1)).xyz;
    vec3 acc = vec3(0);

    for(int s = 0; s < consts.samples; s++) {
        
        const vec2 jitter = consts.frame == 0 ? vec2(0.5) : vec2(randf(seed), randf(seed));
        const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + jitter;
        const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
        vec4 target = cam.iP * vec4(inUV * 2.0 - 1.0, 0, 1);
        vec4 direction = cam.iV * vec4(target.xyz, 0);
        vec3 d = normalize(direction.xyz);

        payload = vec3(0);
        traceRayEXT(topLevelAS,     // acceleration structure
            gl_RayFlagsOpaqueEXT,   // rayFlags
            0xFF,                   // cullMask
            0,                      // sbtRecordOffset
            0,                      // sbtRecordStride
            0,                      // missIndex
            o,                      // ray origin
            0.001,                  // ray min range
            d,                      // ray direction
            10000.0,                // ray max range
            0                       // payload (location = 0)
        );
        acc += payload;
    }

    vec3 avg = acc / consts.samples;
    if(consts.frame > 0) {
        float a         = 1.0f / float(consts.frame + 1);
        vec3  old_color = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(old_color, avg, a), 1.f));
    } else {
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(avg, 1.f));
    }
}
