
#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "bvhcommon.glsl"

#define WIDTH 2
#define MAX_DEPTH 64

struct WideNode {
	vec4 bmin[WIDTH];
    vec4 bmax[WIDTH];
	int next[WIDTH];
    int leaf[WIDTH];
};

layout (binding = 3, std430) readonly buffer Nodes
{
	WideNode nodes[];
};

void ray_primitives(vec3 o, vec3 d, int s, int e, inout vec3 first_hit, inout float best_dist) {
	for (int t = s; t < e; t++) {
		vec3 hitp;
		float hitd;
		bool h = hit_triangle(o, d, hitp, hitd, triangles[t]);
		if(h && hitd < best_dist) {
			best_dist = hitd;
			first_hit = hitp;
		}
	}
}

void cpq_primitives(vec3 q, int s, int e, inout vec3 best_point, inout float best_dist) {
	for (int t = s; t < e; t++) {
		vec3 p = cp_triangle(q, triangles[t]);
		float dt = length(p-q);
		if(dt < best_dist) {
			best_dist = dt;
			best_point = p;
		}
	}
}

void traverse_ray(vec3 o, vec3 d, inout vec3 first_hit, inout float best_dist) {

	uint stack[MAX_DEPTH];
	uint stack_n = 1;
	stack[0] = 0;

	while(stack_n > 0) {
		uint n = stack[--stack_n];
		WideNode node = nodes[n];

		if(node.next[0] < 0) {
			ray_primitives(o, d, node.leaf[0], node.leaf[0] - node.next[0], first_hit, best_dist);
		}
        if(node.next[1] < 0) {
			ray_primitives(o, d, node.leaf[1], node.leaf[1] - node.next[1], first_hit, best_dist);
		}

		float l_boxd, r_boxd;
		bool l_hit = node.next[0] >= 0 && hit_bbox(o, d, node.bmin[0].xyz, node.bmax[0].xyz, best_dist, l_boxd);
		bool r_hit = node.next[1] >= 0 && hit_bbox(o, d, node.bmin[1].xyz, node.bmax[1].xyz, best_dist, r_boxd);
		if(l_hit && r_hit) {
			stack[stack_n++] = l_boxd < r_boxd ? node.next[0] : node.next[1];
			stack[stack_n++] = l_boxd < r_boxd ? node.next[1] : node.next[0];
		} else if(l_hit) {
			stack[stack_n++] = node.next[0];
		} else if(r_hit) {
			stack[stack_n++] = node.next[1];
		}
	}
}

void traverse_cpq(vec3 q, inout vec3 best_point, inout float best_dist) {

	uint stack[MAX_DEPTH];
	uint stack_n = 1;
	stack[0] = 0;

	while(stack_n > 0) {
		uint n = stack[--stack_n];
		WideNode node = nodes[n];

		if(node.next[0] < 0) {
			cpq_primitives(q, node.leaf[0], node.leaf[0] - node.next[0], best_point, best_dist);
		}
        if(node.next[1] < 0) {
			cpq_primitives(q, node.leaf[1], node.leaf[1] - node.next[1], best_point, best_dist);
		}

		float l_close, l_far;
		float r_close, r_far;
		box_dist(q, node.bmin[0].xyz, node.bmax[0].xyz, l_close, l_far);
		box_dist(q, node.bmin[1].xyz, node.bmax[1].xyz, r_close, r_far);
		bool l_hit = node.next[0] >= 0 && l_close < best_dist;
		bool r_hit = node.next[1] >= 0 && r_close < best_dist;

		if(l_hit && r_hit) {
			best_dist = min(best_dist, min(l_far, r_far));
			stack[stack_n++] = l_close < r_close ? node.next[0] : node.next[1];
			stack[stack_n++] = l_close < r_close ? node.next[1] : node.next[0];
		} else if(l_hit) {
			best_dist = min(best_dist, l_far);
			stack[stack_n++] = node.next[0];
		} else if(r_hit) {
			best_dist = min(best_dist, r_far);
			stack[stack_n++] = node.next[1];
		}
	}
}
